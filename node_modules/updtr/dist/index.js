'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var ansiEscapes = _interopDefault(require('ansi-escapes'));
var chalk = _interopDefault(require('chalk'));
var unicons = _interopDefault(require('unicons'));
var Error$1 = _interopDefault(require('es6-error'));
var cliCursor = _interopDefault(require('cli-cursor'));
var stringWidth = _interopDefault(require('string-width'));
var cliSpinners = _interopDefault(require('cli-spinners'));
var os = require('os');
var fs$1 = _interopDefault(require('fs'));
var path = _interopDefault(require('path'));
var yargs = _interopDefault(require('yargs'));
var semver = _interopDefault(require('semver'));
var detectIndent = _interopDefault(require('detect-indent'));
var EventEmitter = _interopDefault(require('events'));
var pify = _interopDefault(require('pify'));
var childProcess = _interopDefault(require('child_process'));

function filterSuccessfulUpdates(results) {
  return results.filter((result) => result.success === true);
}

function filterFailedUpdates(results) {
  return results.filter((result) => result.success === false);
}

class Message {
  constructor(template, variables) {
    this.template = template;
    this.variables = variables;
  }

  valueOf() {
    const split = this.template.split(/%s/g);

    return split.reduce(
    (str, part, i) => str + part + (this.variables[i] || ""),
    "");

  }

  toString() {
    return this.valueOf();
  }}

const INDICATOR_NEUTRAL = 0;
const INDICATOR_FAIL = 1;
const INDICATOR_PENDING = 2;
const INDICATOR_OK = 3;

const COLORS = [chalk.grey, chalk.red, chalk.yellow, chalk.green];

class Indicator {
  constructor(initialState) {
    this.state = initialState;
  }

  valueOf() {
    return COLORS[this.state](unicons.cli("circle"));
  }

  toString() {
    return this.valueOf();
  }}

// The first value in arrays is the default value

const USE_NPM = "npm";
const USE_YARN = "yarn";
const USE_OPTIONS = [USE_NPM, USE_YARN];
const UPDATE_TO_LATEST = "latest";
const UPDATE_TO_NON_BREAKING = "non-breaking";
const UPDATE_TO_WANTED = "wanted";
const UPDATE_TO_OPTIONS = [
UPDATE_TO_LATEST,
UPDATE_TO_NON_BREAKING,
UPDATE_TO_WANTED];

const SAVE_SMART = "smart";
const SAVE_CARET = "caret";
const SAVE_EXACT = "exact";
const SAVE_OPTIONS = [SAVE_SMART, SAVE_CARET, SAVE_EXACT];

const configNames = {
  use: "use",
  exclude: "exclude",
  test: "test command",
  registry: "registry",
  updateTo: "update to",
  save: "save" };


const configValues = {
  exclude: (list) => list.join(", ") };


const configFilter = {
  cwd: () => false,
  use: (option) => option !== USE_OPTIONS[0],
  exclude: (list) => list.length > 0,
  test: (cmd) => cmd !== undefined,
  registry: (reg) => reg !== undefined,
  updateTo: (option) => option !== UPDATE_TO_OPTIONS[0],
  save: (option) => option !== SAVE_OPTIONS[0] };


function configList(config) {
  return Object.keys(config).
  filter((key) => {
    const filter = configFilter[key];
    const name = configNames[key];

    return (
      name !== undefined && (
      filter === undefined || filter(config[key]) === true));

  }).
  map((key) => {
    const toString = configValues[key] || String;

    return `${configNames[key]}: ${toString(config[key])}`;
  });
}

function customConfigToLines(config) {
  const list = configList(config);
  const lines = [];

  if (list.length > 0) {
    lines.push(
    "Running updtr with custom configuration:",
    "",
    ...list.map((item) => unicons.cli("circle") + " " + item),
    "");

  }

  return lines;
}

function pluralize(num) {
  return num === 1 ? "" : "s";
}

// Errors are not extendable in node v4.

class PackageJsonNoAccessError extends Error$1 {
  constructor(dir) {
    super(`Cannot access package.json in ${dir}`);
  }}


class RequiredOptionMissingError extends Error$1 {
  constructor(optionName, optionValue) {
    super(
    `Required option ${optionName} is missing. Instead received ${optionValue}`);

  }}


class OptionValueNotSupportedError extends Error$1 {
  constructor(optionName, unsupportedValue) {
    super(`Unsupported value ${unsupportedValue} for option ${optionName}`);
  }}


class YarnWithCustomRegistryError extends Error$1 {
  constructor() {
    super(
    "yarn does not support custom registries yet. Please use a .npmrc file to achieve this");

  }}

const ERROR = chalk.bgRed.bold(" ERROR ");

function handleError(err) {
  const lines = [""];

  switch (err.constructor) {
    case PackageJsonNoAccessError:
      lines.push(
      ERROR + " Cannot find package.json in current directory.");

      break;
    default:{
        // The stack does only contain \n, also on windows
        const stack = err.stack.split("\n");

        stack.shift();
        lines.push(ERROR + " " + err.message);
        lines.push(...stack.map((line) => chalk.grey(line)));
      }}

  lines.push("");

  console.error(lines.join("\n"));
  process.exit(1); // eslint-disable-line no-process-exit
}

function msToString(milliseconds) {
  return Math.floor(milliseconds / 1000).toFixed(1) + "s";
}

function updatingLine(updateTask) {
  return [
  new Indicator(INDICATOR_PENDING),
  chalk.bold(updateTask.name),
  chalk.grey("updating"),
  updateTask.rollbackTo,
  chalk.grey(unicons.arrowRight),
  updateTask.updateTo + chalk.grey("...")].
  join(" ");
}

function testingLine(updateTask) {
  return [
  new Indicator(INDICATOR_PENDING),
  chalk.bold(updateTask.name),
  chalk.grey("testing...")].
  join(" ");
}

function rollbackLine(updateTask) {
  return [
  new Indicator(INDICATOR_FAIL),
  chalk.bold.red(updateTask.name),
  chalk.grey("rolling back"),
  updateTask.updateTo,
  chalk.grey(unicons.arrowRight),
  updateTask.rollbackTo + chalk.grey("...")].
  join(" ");
}

function successLine(updateTask) {
  return [
  new Indicator(INDICATOR_OK),
  chalk.bold(updateTask.name),
  updateTask.updateTo,
  chalk.grey("success")].
  join(" ");
}

function failLine(updateTask) {
  return [
  new Indicator(INDICATOR_FAIL),
  chalk.bold.red(updateTask.name),
  updateTask.updateTo,
  chalk.grey("failed")].
  join(" ");
}

function excludedLine(excluded) {
  return [
  new Indicator(INDICATOR_NEUTRAL),
  chalk.bold(excluded.name),
  chalk.grey(excluded.reason)].
  join(" ");
}

function cmdToLines(description, cmd) {
  const lines = Array.isArray(description) === true ?
  description :
  [description];

  return lines.concat([chalk.grey(`> ${cmd} `)]);
}

function writeLinesToConsole(lines) {
  if (lines.length === 0) {
    return;
  }
  console.log(ansiEscapes.eraseDown + lines.join("\n"));
}

function basic(updtr, reporterConfig) {
  const startTime = Date.now();
  let excludedModules;

  updtr.on("start", ({ config }) => {
    writeLinesToConsole(customConfigToLines(config));
  });
  updtr.on("init/install-missing", ({ cmd }) => {
    writeLinesToConsole(
    cmdToLines(
    "Installing missing dependencies" + chalk.grey("..."),
    cmd));


  });
  updtr.on("init/collect", ({ cmd }) => {
    writeLinesToConsole(
    cmdToLines("Looking for outdated modules" + chalk.grey("..."), cmd));

  });
  updtr.on("init/end", ({ updateTasks, excluded }) => {
    excludedModules = excluded;
    if (updateTasks.length === 0 && excluded.length === 0) {
      writeLinesToConsole(["Everything " + chalk.bold("up-to-date")]);
    } else if (updateTasks.length === 0) {
      writeLinesToConsole([
      chalk.bold("No updates available") +
      " for the given modules and version range"]);

    } else {
      writeLinesToConsole([
      new Message("Found " + chalk.bold("%s update%s") + ".", [
      updateTasks.length,
      pluralize(updateTasks.length)]),

      ""]);

    }
  });
  updtr.on("batch-update/updating", (event) => {
    writeLinesToConsole(
    cmdToLines(event.updateTasks.map(updatingLine), event.cmd));

  });
  updtr.on("batch-update/testing", (event) => {
    writeLinesToConsole(
    cmdToLines(event.updateTasks.map(testingLine), event.cmd));

  });
  updtr.on("batch-update/rollback", (event) => {
    writeLinesToConsole(
    cmdToLines(event.updateTasks.map(rollbackLine), event.cmd));

  });
  updtr.on("batch-update/result", (event) => {
    if (event.success === true) {
      writeLinesToConsole(
      event.updateTasks.map(event.success ? successLine : failLine));

    }
    // Not showing the test stdout here when there was an error because
    // we will proceed with the sequential update.
  });
  updtr.on("sequential-update/updating", (event) => {
    writeLinesToConsole(cmdToLines(updatingLine(event), event.cmd));
  });
  updtr.on("sequential-update/testing", (event) => {
    writeLinesToConsole(cmdToLines(testingLine(event), event.cmd));
  });
  updtr.on("sequential-update/rollback", (event) => {
    writeLinesToConsole(cmdToLines(rollbackLine(event), event.cmd));
  });
  updtr.on("sequential-update/result", (event) => {
    writeLinesToConsole([(event.success ? successLine : failLine)(event)]);
    if (reporterConfig.testStdout === true && event.success === false) {
      writeLinesToConsole([event.stdout]);
    }
  });
  updtr.on("end", ({ results }) => {
    const duration = msToString(Date.now() - startTime);
    const successful = filterSuccessfulUpdates(results);
    const failed = filterFailedUpdates(results);

    writeLinesToConsole([""]);

    if (successful.length > 0) {
      writeLinesToConsole([
      new Message(chalk.bold("%s successful") + " update%s.", [
      successful.length,
      pluralize(successful.length)])]);


    }
    if (failed.length > 0) {
      writeLinesToConsole([
      new Message(chalk.bold("%s failed") + " update%s.", [
      failed.length,
      pluralize(failed.length)])]);


    }
    if (excludedModules.length > 0) {
      const list = excludedModules.map(excludedLine);

      if (successful.length > 0 || failed.length > 0) {
        writeLinesToConsole([""]);
      }
      writeLinesToConsole(
      [
      new Message(chalk.bold("%s skipped") + " module%s:", [
      excludedModules.length,
      pluralize(excludedModules.length)]),

      ""].
      concat(list));

    }

    writeLinesToConsole(["", new Message("Finished after %s.", [duration])]);
  });
  updtr.on("error", (err) => void handleError(err));
}

function lineToString(line) {
  if (Array.isArray(line) === true) {
    return line.join("");
  }

  return String(line);
}

class Projector {
  constructor(terminal, frameRate = 10) {
    this.terminal = terminal;
    this.delay = Math.floor(1000 / frameRate);
    this.timeoutId = null;
  }

  display(frame) {
    if (this.timeoutId !== null) {
      this.stop();
    }
    this.terminal.append(frame.map(lineToString));
    this.timeoutId = setTimeout(() => {
      this.display(frame);
    }, this.delay);
  }

  stop() {
    if (this.timeoutId === null) {
      return;
    }
    this.terminal.rewind();
    clearTimeout(this.timeoutId);
    this.timeoutId = null;
  }}

function calcNumOfRows(lines, columns) {
  return lines.
  map((lineContent) => Math.ceil(stringWidth(lineContent) / columns)).
  reduce((allRows, rows) => allRows + rows, 0);
}

// Solves some issues where stdout output is truncated
// See https://github.com/nodejs/node/issues/6456
function setBlocking(stream) {
  if (stream._handle && typeof stream._handle.setBlocking === "function") {
    stream._handle.setBlocking(true);
  }
}

class Terminal {
  constructor(stream) {
    if (stream.isTTY !== true) {
      throw new Error("Given stream is not a TTY stream");
    }
    setBlocking(stream);
    cliCursor.hide(stream);
    this.stream = stream;
    this.lines = [];
    this.hasBeenResized = false;
    this.stream.on("resize", () => {
      this.hasBeenResized = true;
    });
  }

  append(lines) {
    if (lines.length === 0) {
      return;
    }
    this.lines.push(lines);

    const content = this.hasBeenResized === true ?
    ansiEscapes.clearScreen +
    this.lines.map((lines) => lines.join("\n")).join("\n") :
    ansiEscapes.eraseDown + lines.join("\n");

    this.stream.write(content + "\n");
    this.hasBeenResized = false;
  }

  rewind() {
    const removedLines = this.lines.pop();
    const rows = calcNumOfRows(removedLines, this.stream.columns);

    this.stream.write(ansiEscapes.cursorUp(rows));
  }}

const isWin = process.platform === "win32";
const winFallback = "simpleDotsScrolling";

class Spinner {
  constructor(spinnerName) {
    const spinner = cliSpinners[isWin === true ? winFallback : spinnerName];

    this.frames = spinner.frames;
    this.interval = spinner.interval;
    this.length = Math.max(...this.frames.map((frame) => frame.length));
  }

  valueOf() {
    const currentInterval = Math.floor(Date.now() / this.interval);
    const currentFrame = currentInterval % this.frames.length;

    return this.frames[currentFrame];
  }

  toString() {
    return this.valueOf();
  }}

const spinner = new Spinner("dots");

function updatingLine$1(updateTask) {
  return [
  new Indicator(INDICATOR_PENDING),
  chalk.bold(updateTask.name),
  chalk.grey("updating"),
  updateTask.rollbackTo,
  chalk.grey(unicons.arrowRight),
  updateTask.updateTo + chalk.grey("...")].
  join(" ");
}

function testingLine$1(updateTask) {
  return [
  new Indicator(INDICATOR_PENDING),
  chalk.bold(updateTask.name),
  chalk.grey("testing...")].
  join(" ");
}

function rollbackLine$1(updateTask) {
  return [
  new Indicator(INDICATOR_FAIL),
  chalk.bold.red(updateTask.name),
  chalk.grey("rolling back"),
  updateTask.updateTo,
  chalk.grey(unicons.arrowRight),
  updateTask.rollbackTo + chalk.grey("...")].
  join(" ");
}

function successLine$1(updateTask) {
  return [
  new Indicator(INDICATOR_OK),
  chalk.bold(updateTask.name),
  updateTask.updateTo,
  chalk.grey("success")].
  join(" ");
}

function failLine$1(updateTask) {
  return [
  new Indicator(INDICATOR_FAIL),
  chalk.bold.red(updateTask.name),
  updateTask.updateTo,
  chalk.grey("failed")].
  join(" ");
}

function excludedLine$1(excluded) {
  return [
  new Indicator(INDICATOR_NEUTRAL),
  chalk.bold(excluded.name),
  chalk.grey(excluded.reason)].
  join(" ");
}

function cmdToLines$1(description, cmd) {
  const lines = Array.isArray(description) === true ?
  description :
  [description];

  return lines.concat([chalk.grey(`> ${cmd} `), spinner]);
}

function dense(updtr, reporterConfig) {
  const terminal = new Terminal(reporterConfig.stream);
  const projector = new Projector(terminal);
  const startTime = Date.now();
  let excludedModules;

  updtr.on("start", ({ config }) => {
    terminal.append(customConfigToLines(config));
  });
  updtr.on("init/install-missing", ({ cmd }) => {
    projector.display(
    cmdToLines$1(
    "Installing missing dependencies" + chalk.grey("..."),
    cmd));


  });
  updtr.on("init/collect", ({ cmd }) => {
    projector.display(
    cmdToLines$1("Looking for outdated modules" + chalk.grey("..."), cmd));

  });
  updtr.on("init/end", ({ updateTasks, excluded }) => {
    excludedModules = excluded;
    projector.stop();
    if (updateTasks.length === 0 && excluded.length === 0) {
      terminal.append(["Everything " + chalk.bold("up-to-date")]);
    } else if (updateTasks.length === 0) {
      terminal.append([
      chalk.bold("No updates available") +
      " for the given modules and version range"]);

    } else {
      terminal.append([
      new Message("Found " + chalk.bold("%s update%s") + ".", [
      updateTasks.length,
      pluralize(updateTasks.length)]),

      ""]);

    }
  });
  updtr.on("batch-update/updating", (event) => {
    projector.display(
    cmdToLines$1(event.updateTasks.map(updatingLine$1), event.cmd));

  });
  updtr.on("batch-update/testing", (event) => {
    projector.display(
    cmdToLines$1(event.updateTasks.map(testingLine$1), event.cmd));

  });
  updtr.on("batch-update/rollback", (event) => {
    projector.display(
    cmdToLines$1(event.updateTasks.map(rollbackLine$1), event.cmd));

  });
  updtr.on("batch-update/result", (event) => {
    projector.stop();
    if (event.success === true) {
      terminal.append(
      event.updateTasks.map(event.success ? successLine$1 : failLine$1));

    }
    // Not showing the test stdout here when there was an error because
    // we will proceed with the sequential update.
  });
  updtr.on("sequential-update/updating", (event) => {
    projector.display(cmdToLines$1(updatingLine$1(event), event.cmd));
  });
  updtr.on("sequential-update/testing", (event) => {
    projector.display(cmdToLines$1(testingLine$1(event), event.cmd));
  });
  updtr.on("sequential-update/rollback", (event) => {
    projector.display(cmdToLines$1(rollbackLine$1(event), event.cmd));
  });
  updtr.on("sequential-update/result", (event) => {
    projector.stop();
    terminal.append([(event.success ? successLine$1 : failLine$1)(event)]);
    if (reporterConfig.testStdout === true && event.success === false) {
      terminal.append([event.stdout]);
    }
  });
  updtr.on("end", ({ results }) => {
    const duration = msToString(Date.now() - startTime);
    const successful = filterSuccessfulUpdates(results);
    const failed = filterFailedUpdates(results);

    terminal.append([""]);

    if (successful.length > 0) {
      terminal.append([
      new Message(chalk.bold("%s successful") + " update%s.", [
      successful.length,
      pluralize(successful.length)])]);


    }
    if (failed.length > 0) {
      terminal.append([
      new Message(chalk.bold("%s failed") + " update%s.", [
      failed.length,
      pluralize(failed.length)])]);


    }
    if (excludedModules.length > 0) {
      const list = excludedModules.map(excludedLine$1);

      if (successful.length > 0 || failed.length > 0) {
        terminal.append([""]);
      }
      terminal.append(
      [
      new Message(chalk.bold("%s skipped") + " module%s:", [
      excludedModules.length,
      pluralize(excludedModules.length)]),

      ""].
      concat(list));

    }

    terminal.append(["", new Message("Finished after %s.", [duration])]);
  });
  updtr.on("error", (err) => void handleError(err));
}

var none = Function.prototype;

// The first property here is the default reporter
const reporters = { dense, basic, none };

const reporterNames = Object.keys(reporters);
const pathToYarnLock = path.join(process.cwd(), "yarn.lock");
const useDefault = fs$1.existsSync(pathToYarnLock) === true ? USE_YARN : USE_NPM;

var argv = yargs.
usage(
[
"",
chalk.bold.cyan("Update outdated npm modules with zero painâ„¢"),
`${chalk.bold("Usage:")} $0 ${chalk.dim("[options]")}`].
join(os.EOL)).

option("use", {
  describe: "Specify the package manager to use",
  choices: USE_OPTIONS,
  default: useDefault,
  alias: "u" }).

option("exclude", {
  describe: "Space separated list of module names that should not be updated",
  array: true,
  alias: "ex" }).

option("update-to", {
  describe: "Specify which updates you want to install",
  choices: UPDATE_TO_OPTIONS,
  default: UPDATE_TO_OPTIONS[0],
  alias: "to" }).

option("save", {
  describe: "Specify how updated versions should be saved to the package.json",
  choices: SAVE_OPTIONS,
  default: SAVE_OPTIONS[0],
  alias: "s" }).

option("reporter", {
  describe: "Choose a reporter for the console output",
  choices: reporterNames,
  default: reporterNames[0],
  alias: "r" }).

option("test", {
  describe: "Specify a custom test command. Surround with quotes.",
  alias: "t" }).

option("test-stdout", {
  describe: "Show test stdout if the update fails",
  boolean: true,
  default: false,
  alias: "out" }).

option("registry", {
  describe: "Specify a custom registry to use",
  alias: "reg" }).

version().
wrap(null).
help().argv;

class Sequence {
  constructor(name, updtr, baseEvent = {}) {
    this.name = name;
    this.updtr = updtr;
    this.baseEvent = baseEvent;
    this.isRunning = false;
  }

  start() {
    this.isRunning = true;
    this.emit("start");
  }

  emit(eventName, event = {}) {
    const fullEventName = this.name + "/" + eventName;

    if (this.isRunning === false) {
      throw new Error(
      `Cannot emit event ${fullEventName}: sequence is not running`);

    }
    this.updtr.emit(fullEventName, {
      ...this.baseEvent,
      ...event });

  }

  exec(step, cmd) {
    this.emit(step, { cmd });

    return this.updtr.exec(cmd);
  }

  end(result) {
    this.emit("end", result);
    this.isRunning = false;
  }}

function determineUpdateToVersion({ current, wanted, latest }, { updateTo }) {
  switch (updateTo) {
    case UPDATE_TO_LATEST:
      return latest;
    case UPDATE_TO_WANTED:
      return wanted;
    case UPDATE_TO_NON_BREAKING:
    default:
      return "^" + current;}

}

function isUpdateToNonBreaking(updateTask) {
  return updateTask.updateTo === "^" + updateTask.rollbackTo;
}

function createUpdateTask(outdated, updtrConfig) {
  return {
    name: outdated.name,
    updateTo: determineUpdateToVersion(outdated, updtrConfig),
    rollbackTo: outdated.current };

}

const GIT = "git";
const EXOTIC = "exotic";
const UNSTABLE = "unstable";
const EXCLUDED = "excluded";
const NOT_WANTED = "not-wanted";

const prePattern = /^pre/;

const reasonTests = [
{
  name: EXCLUDED,
  test: (updateTask, { exclude }) =>
  exclude.some((name) => updateTask.name === name) === true },

{
  name: GIT,
  test: (updateTask) => updateTask.updateTo === "git" },

{
  name: EXOTIC,
  test: (updateTask) => updateTask.updateTo === "exotic" },

{
  name: NOT_WANTED,
  test: (updateTask) =>
  isUpdateToNonBreaking(updateTask) === false &&
  semver.lte(updateTask.updateTo, updateTask.rollbackTo) === true },

{
  name: UNSTABLE,
  test(updateTask) {
    if (isUpdateToNonBreaking(updateTask) === true) {
      return null;
    }

    const diff = semver.diff(
    updateTask.rollbackTo,
    updateTask.updateTo);


    const unstableTest = diff !== null &&
    prePattern.test(diff) === true &&
    diff !== "prerelease";

    return unstableTest === true;
  } }];



const reasons = reasonTests.map((test) => test.name);

function filterUpdateTask(updateTask, updtrConfig) {
  const reasonIndex = reasonTests.findIndex(
  (reasonTest) => reasonTest.test(updateTask, updtrConfig) === true);


  return reasonIndex === -1 ? null : reasons[reasonIndex];
}

function getUpdateTasksFromStdout(updtr, outdatedCmd, stdout) {
  if (stdout.length === 0) {
    // When there is not stdout, there is nothing to update
    return [];
  }

  return updtr.parse.
  outdated(stdout, outdatedCmd).
  map((outdated) => createUpdateTask(outdated, updtr.config));
}

var init = (async function init(updtr) {
  const baseEvent = { config: updtr.config };
  const outdatedCmd = updtr.cmds.outdated();
  const sequence = new Sequence("init", updtr, baseEvent);
  let stdout;

  sequence.start();

  if ((await updtr.canAccessPackageJson()) === false) {
    throw new PackageJsonNoAccessError(updtr.config.cwd);
  }

  await sequence.exec(
  "install-missing",
  updtr.cmds.installMissing({
    registry: updtr.config.registry }));



  try {
    stdout = (await sequence.exec("collect", outdatedCmd)).stdout;
  } catch (err) {
    // npm exits with zero code 1 when there are outdated dependencies
    // We don't check for the package manager here because yarn might change their
    // behavior in the future to be npm-compatible.
    if (err.code > 1) {
      throw err;
    }

    stdout = err.stdout;
  }

  const allUpdateTasks = getUpdateTasksFromStdout(
  updtr,
  outdatedCmd,
  stdout.trim());


  const filterResults = allUpdateTasks.map((updateTask) =>
  filterUpdateTask(updateTask, updtr.config));

  const result = {
    updateTasks: allUpdateTasks.filter(
    (updateTask, index) => filterResults[index] === null),

    excluded: allUpdateTasks.reduce(
    (excluded, updateTask, index) => {
      const reason = filterResults[index];

      if (reason === null) {
        return excluded;
      }

      return excluded.concat({
        ...updateTask,
        reason });

    },
    []) };



  sequence.end(result);

  return result;
});

function createUpdateResult(updateTask, success) {
  return {
    name: updateTask.name,
    updateTo: updateTask.updateTo,
    rollbackTo: updateTask.rollbackTo,
    success };

}

function updateTo(updateTask) {
  return {
    name: updateTask.name,
    version: updateTask.updateTo };

}

function rollbackTo(updateTask) {
  return {
    name: updateTask.name,
    version: updateTask.rollbackTo };

}

/* eslint-disable require-atomic-updates */

function renderUpdate(updtr, updateTask) {
  return updtr.cmds.install({
    registry: updtr.config.registry,
    modules: [updateTo(updateTask)] });

}

function renderTest(updtr) {
  return updtr.cmds.test();
}

function renderRollback(updtr, failedUpdateTask, nextUpdateTask) {
  const modules = [rollbackTo(failedUpdateTask)];

  if (nextUpdateTask !== undefined) {
    modules.push(updateTo(nextUpdateTask));
  }

  return updtr.cmds.install({
    registry: updtr.config.registry,
    modules });

}

async function runUpdateTask(sequence, updateTasks, i, previousUpdateResults) {
  const updateResults = await previousUpdateResults;
  const previousUpdateResult = updateResults[updateResults.length - 1];
  const updateTask = updateTasks[i];

  // If the previous update was a failure, we don't need to update now because
  // during the rollback, the next update is also installed in parallel
  const updateNecessary = previousUpdateResult === undefined ?
  true :
  previousUpdateResult.success === true;

  sequence.baseEvent = {
    updateTasks: {
      current: i + 1,
      total: updateTasks.length },

    ...updateTask };

  const updtr = sequence.updtr;
  let testResult;
  let success;

  if (updateNecessary === true) {
    await sequence.exec("updating", renderUpdate(updtr, updateTask));
  }

  try {
    testResult = await sequence.exec("testing", renderTest(updtr));
    success = true;
  } catch (err) {
    // Remember: instanceof Error might not work in Jest as expected
    // https://github.com/facebook/jest/issues/2549
    testResult = err;
    success = false;
  }

  sequence.baseEvent.success = success;

  if (success === false) {
    const nextUpdateTask = i + 1 < updateTasks.length ?
    updateTasks[i + 1] :
    undefined;

    await sequence.exec(
    "rollback",
    renderRollback(updtr, updateTask, nextUpdateTask));

  }

  sequence.emit("result", {
    stdout: testResult.stdout });


  return updateResults.concat(createUpdateResult(updateTask, success));
}

var sequentialUpdate = (async function sequentialUpdate(
updtr,
updateTasks,
previousUpdateResult)
{
  const sequence = new Sequence("sequential-update", updtr, {
    updateTasks });


  if (updateTasks.length === 0) {
    return [];
  }

  sequence.start();

  const updateResults = await updateTasks.reduce(
  (updateResults, updateTask, i) =>
  runUpdateTask(sequence, updateTasks, i, updateResults),
  previousUpdateResult === undefined ? [] : [previousUpdateResult]);


  if (previousUpdateResult !== undefined) {
    // The previousUpdateResult is the first element in the updateResults array, so let's remove it.
    updateResults.shift();
  }

  sequence.baseEvent = {
    updateResults };


  sequence.end();

  return updateResults;
});

function isBreaking(updateTask) {
  return isUpdateToNonBreaking(updateTask) === false &&
  semver.satisfies(updateTask.updateTo, "^" + updateTask.rollbackTo) ===
  false;
}

function splitUpdateTask(updateTasks) {
  const breaking = [];
  const nonBreaking = [];

  for (const updateTask of updateTasks) {
    (isBreaking(updateTask) === true ? breaking : nonBreaking).push(
    updateTask);

  }

  return {
    breaking,
    nonBreaking };

}

function renderUpdate$1(updtr, updateTask) {
  return updtr.cmds.install({
    registry: updtr.config.registry,
    modules: updateTask.map(updateTo) });

}

function renderTest$1(updtr) {
  return updtr.cmds.test();
}

function renderRollback$1(updtr, failedUpdateTasks) {
  return updtr.cmds.install({
    registry: updtr.config.registry,
    modules: failedUpdateTasks.map(rollbackTo) });

}

async function update(sequence, updateTasks) {
  const updtr = sequence.updtr;
  let success;
  let testResult;

  await sequence.exec("updating", renderUpdate$1(updtr, updateTasks));
  try {
    testResult = await sequence.exec("testing", renderTest$1(updtr));
    success = true;
  } catch (err) {
    // Remember: instanceof Error might not work in Jest as expected
    // https://github.com/facebook/jest/issues/2549
    testResult = err;
    success = false;
  }

  // eslint-disable-next-line require-atomic-updates
  sequence.baseEvent.success = success;

  if (success === false && updateTasks.length > 1) {
    // If the update was a failure, we roll back every update except the first.
    // The first update will be tested with the sequential-update. This way we skip one unnecessary install cycle.
    await sequence.exec(
    "rollback",
    renderRollback$1(updtr, updateTasks.slice(1)));

  }

  sequence.emit("result", {
    stdout: testResult.stdout });


  return success;
}

var batchUpdate = (async function batchUpdate(updtr, updateTasks) {
  const sequence = new Sequence("batch-update", updtr, {
    updateTasks });


  let success = true;

  if (updateTasks.length > 0) {
    sequence.start();
    success = await update(sequence, updateTasks);
    sequence.baseEvent = {
      success };

    sequence.end();
  }

  return success;
});

function isIncompleteResult(result) {
  return result.success === true && isUpdateToNonBreaking(result) === true;
}

async function finishIncomplete(sequence, incomplete, allResults) {
  const updtr = sequence.updtr;
  const modulesToCheck = incomplete.map((result) => result.name);
  const listCmd = updtr.cmds.list({ modules: modulesToCheck });
  let stdout;

  try {
    stdout = (await sequence.exec("list-incomplete", listCmd)).stdout;
  } catch (err) {
    // npm may exit with zero code 1 complaining about invalid installed versions
    if (err.code > 1) {
      throw err;
    }
    stdout = err.stdout;
  }
  const moduleVersions = updtr.parse.list(stdout, listCmd);

  return (
    allResults.
    map((result) => {
      if (isIncompleteResult(result) === false) {
        return result;
      }

      const version = moduleVersions.find(
      (module) => module.name === result.name).
      version;

      return {
        ...result,
        updateTo: version };

    })
    // Remove results where no actual update did happen.
    // These results can happen if the updateTo option was set to non-breaking
    // and the module did not have a new version for the rollbackTo version range.
    .filter((result) => result.rollbackTo !== result.updateTo));

}

var finish = (async function finish(updtr, results) {
  const incomplete = results.filter(isIncompleteResult);
  const sequence = new Sequence("finish", updtr);
  let finishedResults = results;

  if (incomplete.length > 0) {
    sequence.start();
    sequence.emit("incomplete", { incomplete });
    finishedResults = await finishIncomplete(sequence, incomplete, results);
    sequence.end({ results: finishedResults });
  }

  return finishedResults;
});

// Matches a semver version range that can be transformed to the new version in a safe manner
// eslint-disable-next-line optimize-regex/optimize-regex
const expectedSemverPattern = /^(\^|~|>=|)(\d+)\.(\d+|x|\*)\.(\d+|x|\*)(-[a-z][\d\-.a-z]+|)$/i;
const numberPattern = /^\d+$/;

function parse(semverString) {
  const match = semverString.match(expectedSemverPattern);

  return match === null ?
  null :
  {
    operator: match[1],
    major: match[2],
    minor: match[3],
    patch: match[4],
    release: match[5] };

}

function isPinned({ operator, major, minor, patch }) {
  return operator === "" &&
  [major, minor, patch].every(
  (version) => numberPattern.test(version) === true);

}

function tryVersionRangeUpdate(parsedOldRange, parsedNewVersion) {
  const { minor, patch, operator } = parsedOldRange;
  let newMinor = parsedNewVersion.minor;
  let newPatch = parsedNewVersion.patch;

  if (numberPattern.test(minor) === false) {
    newMinor = minor;
    newPatch = numberPattern.test(patch) === true ? minor : patch;
  } else if (numberPattern.test(patch) === false) {
    newPatch = patch;
  }

  return operator +
  parsedNewVersion.major +
  "." +
  newMinor +
  "." +
  newPatch +
  parsedNewVersion.release;
}

function isExpectedNewVersion(parsedNewVersion) {
  return parsedNewVersion !== null && parsedNewVersion.operator === "";
}

function fallbackRange(newVersion) {
  return "^" + newVersion;
}

/**
 * Tries to apply the newVersion while maintaining the range (see https://github.com/peerigon/updtr/issues/47)
 * This is kind of risky because there are tons of semver possibilities. That's why this
 * function is very conservative in accepting semver ranges. If the range is not easily updatable,
 * we opt-out to npm's default caret operator.
 *
 * @param {string} oldRange
 * @param {string} newVersion
 * @returns {string}
 */
function updateVersionRange(oldRange, newVersion) {
  const parsedOldRange = parse(oldRange.trim());

  if (parsedOldRange !== null) {
    if (isPinned(parsedOldRange) === true) {
      // The old version was pinned, so the new should also be pinned
      return newVersion;
    }

    const parsedNewVersion = parse(newVersion);

    if (isExpectedNewVersion(parsedNewVersion) === false) {
      return newVersion;
    }

    const newVersionRange = tryVersionRangeUpdate(
    parsedOldRange,
    parsedNewVersion);


    // All this is kind of error prone so let's do a sanity check if everything's ok
    if (semver.satisfies(newVersion, newVersionRange) === true) {
      return newVersionRange;
    }
  }

  return fallbackRange(newVersion);
}

const dependencyTypes = [
"dependencies",
"devDependencies",
"optionalDependencies"];


function newVersionRange(updtrConfig, oldVersionRange, update) {
  switch (updtrConfig.save) {
    case SAVE_CARET:
      return "^" + update.updateTo;
    case SAVE_EXACT:
      return update.updateTo;
}


  return updateVersionRange(oldVersionRange, update.updateTo);
}

function createUpdatedPackageJson(
oldPackageJson,
updateResults,
updtrConfig)
{
  const newPackageJson = { ...oldPackageJson };
  const successfulUpdates = filterSuccessfulUpdates(updateResults);
  let dependenciesToSave = successfulUpdates;

  dependencyTypes.
  filter((type) => oldPackageJson[type] !== undefined).
  forEach((type) => {
    const dependencies = oldPackageJson[type];
    const newDependencies = {};

    Object.keys(dependencies).forEach((moduleName) => {
      const update = successfulUpdates.find(
      ({ name }) => name === moduleName);


      const oldVersionRange = dependencies[moduleName];

      newDependencies[moduleName] = update === undefined ?
      oldVersionRange :
      newVersionRange(updtrConfig, oldVersionRange, update);

      dependenciesToSave = dependenciesToSave.filter(
      ({ name }) => name !== moduleName);

    });

    newPackageJson[type] = newDependencies;
  });

  if (dependenciesToSave.length > 0) {
    const dependencies = newPackageJson.dependencies || {};

    dependenciesToSave.forEach((update) => {
      dependencies[update.name] = update.updateTo;
    });

    newPackageJson.dependencies = dependencies;
  }

  return newPackageJson;
}

function lastChar(str) {
  return str.charAt(str.length - 1);
}

function stringify(newPackageJson, oldPackageJsonStr) {
  const indent = detectIndent(oldPackageJsonStr).indent || "  ";
  let newPackageJsonStr = JSON.stringify(newPackageJson, null, indent);
  const lastCharFromOldPackageJson = lastChar(oldPackageJsonStr);

  // Preserve the new line character at the end if there was one
  if (lastCharFromOldPackageJson !== lastChar(newPackageJsonStr)) {
    newPackageJsonStr += lastCharFromOldPackageJson;
  }

  return newPackageJsonStr;
}

async function enhanceErrorMessage(fn, enhancedMessage) {
  try {
    return await fn();
  } catch (err) {
    err.message = enhancedMessage + err.message;
    throw err;
  }
}

var updatePackageJson = (async function updatePackageJson(updtr, updateResults) {
  const sequence = new Sequence("update-package-json", updtr);
  let oldPackageJsonStr;

  sequence.start();

  const oldPackageJson = await enhanceErrorMessage(
  async () => {
    oldPackageJsonStr = await updtr.readFile("package.json");

    return JSON.parse(oldPackageJsonStr);
  },
  "Error while trying to read the package.json: ");


  const newPackageJson = createUpdatedPackageJson(
  oldPackageJson,
  updateResults,
  updtr.config);


  await enhanceErrorMessage(
  () =>
  updtr.writeFile(
  "package.json",
  stringify(newPackageJson, oldPackageJsonStr)),

  "Error while trying to write the package.json: ");


  sequence.end({
    packageJson: newPackageJson });

});

async function runUpdateTasks(updtr, updateTasks) {
  const results = [];
  const { breaking, nonBreaking } = splitUpdateTask(updateTasks);
  const sequentialUpdateTasks = breaking.slice();
  let batchSuccess; // can be undefined, true or false
  let batchUpdateFailure;

  // Run batch update if we have more than one non-breaking update
  // If the batch update fails, it will roll back all modules except the first one.
  // This way we can skip one install command since we will run the sequential update for it anyway.
  if (nonBreaking.length > 1) {
    batchSuccess = await batchUpdate(updtr, nonBreaking);
  }

  if (batchSuccess === true) {
    results.push(
    ...nonBreaking.map((updateTask) =>
    createUpdateResult(updateTask, true)));


  } else {
    sequentialUpdateTasks.unshift(...nonBreaking);
    // If batchSuccess is false, we have actually executed the batch update and it returned false
    if (batchSuccess === false) {
      batchUpdateFailure = createUpdateResult(nonBreaking[0], false);
    }
  }

  // Run sequential update for all breaking updates and non-breaking batch updates that failed
  results.push(
  ...(await sequentialUpdate(
  updtr,
  sequentialUpdateTasks,
  batchUpdateFailure)));



  return finish(updtr, results);
}

var run = (async function run(updtr) {
  const results = [];

  updtr.emit("start", {
    config: updtr.config });


  const { updateTasks } = await init(updtr);

  if (updateTasks.length > 0) {
    results.push(...(await runUpdateTasks(updtr, updateTasks)));
    await updatePackageJson(updtr, results);
  }

  updtr.emit("end", {
    config: updtr.config,
    results });


  return results;
});

var fs = pify(fs$1);

function promiseExec(cwd, cmd) {
  return new Promise((resolve) => {
    childProcess.exec(
    cmd,
    { maxBuffer: Infinity, encoding: "utf8", cwd },
    // We need to use the callback API here
    (err, stdout, stderr) => void resolve({ err, stdout, stderr }) // eslint-disable-line promise/prefer-await-to-callbacks
    );
  });
}

var exec = (async function exec(cwd, cmd) {
  const { err, stdout, stderr } = await promiseExec(cwd, cmd);

  if (err !== null) {
    err.stdout = stdout;
    err.stderr = stderr;

    throw err;
  }

  return { stdout, stderr };
});

function installFn(baseCmd) {
  return ({ registry, modules } = {}) =>
  [baseCmd, stringifyRegistry(registry), stringifyModules(modules)].join(
  "");

}

function stringifyModules(modules) {
  return Array.isArray(modules) === true ?
  " " +
  modules
  // We need to wrap this in double-quotes because some semver
  // characters like the caret symbol are reserved characters on Windows.
  .map(({ name, version }) => `"${name}@${version}"`).
  join(" ") :
  "";
}

function stringifyRegistry(registry) {
  return registry === undefined ? "" : ` --registry "${registry}"`;
}

const cmds = {
  npm: {
    outdated: () => "npm outdated --json --depth=0",
    installMissing: installFn("npm install"),
    install: installFn("npm install"),
    // remove: ({ name }) => ["npm remove ", name].join(""),
    test: () => "npm test",
    list: ({ modules } = {}) => [
    "npm ls --json --depth=0",
    Array.isArray(modules) === true ? " " + modules.join(" ") : ""].
    join("") },

  // yarn does not support custom registries yet.
  // However, these renderers accept them anyway.
  yarn: {
    outdated: () => "yarn outdated --json --flat",
    installMissing: installFn("yarn"),
    install: installFn("yarn add"),
    // remove: ({ name }) => ["yarn remove ", name].join(""),
    test: () => "yarn test",
    list: ({ modules } = {}) => [
    "yarn list --json --depth=0",
    Array.isArray(modules) === true ? " " + modules.join(" ") : ""].
    join("") } };

const STRING_PROPERTIES = ["name", "current", "wanted", "latest"];

function isNotEmptyString(value) {
  return typeof value === "string" && value.length > 0;
}

function returnIfValid(result) {
  STRING_PROPERTIES.forEach((prop) => {
    if (isNotEmptyString(result[prop]) === false) {
      throw new Error("Unexpected output format of package manager");
    }
  });

  return result;
}

function tryParse(parser) {
  return (stdout, cmd) => {
    try {
      return parser(stdout);
    } catch (err) {
      err.message = `Error when trying to parse stdout from command '${cmd}': ${err.message}`;
      throw err;
    }
  };
}

function arrToObj(arr, keys) {
  return keys.reduce((obj, key, i) => {
    obj[key] = arr[i];

    return obj;
  }, {});
}

// By sorting the parsed data, we get deterministic results across different npm and yarn versions.
// As a nice side-effect, a package like eslint will always be updated before eslint-config-peerigon
// which might have a peer dependency on eslint
// See https://github.com/peerigon/updtr/issues/48
function sortByName(o1, o2) {
  return o1.name > o2.name;
}

function npmParser(stdout) {
  const trimmed = stdout.trim();

  if (trimmed.length === 0) {
    return null;
  }

  return JSON.parse(trimmed);
}

function splitYarnLines(stdout) {
  // Yarn is using \n on all platforms now in their stdout
  return stdout.split("\n");
}

function yarnParser(stdout, wantedTypeProperty) {
  try {
    return npmParser(stdout);
  } catch (error) {
    /* in some cases (e.g. when printing the outdated result), yarn prints for each line a separate JSON object */
    /* in that case, we need to look for a { type: "table" } object which holds the interesting data to display */
  }
  const dataLine = splitYarnLines(stdout).
  map((line) => line.trim()).
  filter((line) => line !== "").
  find((line) => {
    try {
      console.log(line);
      const parsedLine = JSON.parse(line);

      return parsedLine.type === wantedTypeProperty;
    } catch (error) {
      console.log(error);

      return false;
    }
  });

  if (dataLine === undefined) {
    throw new Error(`Could not find object with type === ${wantedTypeProperty}`);
  }

  return JSON.parse(dataLine);
}

const parse$1 = {
  npm: {
    outdated: tryParse((stdout) => {
      const parsed = npmParser(stdout);

      if (parsed === null) {
        return [];
      }

      const names = Object.keys(parsed);

      return names.
      map((name) => parsed[name]).
      map((dep, index) =>
      returnIfValid({
        name: names[index],
        current: dep.current,
        wanted: dep.wanted,
        latest: dep.latest })).


      sort(sortByName);
    }),
    list: tryParse((stdout) => {
      const parsed = npmParser(stdout);

      return parsed.dependencies === undefined ?
      [] :
      Object.keys(parsed.dependencies).
      map((name) => ({
        name,
        version: parsed.dependencies[name].version })).

      sort(sortByName);
    }) },

  yarn: {
    outdated: tryParse(
    (stdout) => {
      const parsed = yarnParser(stdout, "table");

      if (parsed === null) {
        return [];
      }

      return parsed.data.body.
      map((row) => arrToObj(row, parsed.data.head)).
      map((dep) =>
      returnIfValid({
        name: dep.Package,
        current: dep.Current,
        wanted: dep.Wanted,
        latest: dep.Latest })).


      sort(sortByName);
    }),

    list: tryParse((stdout) => {
      const parsed = yarnParser(stdout, "tree");

      if (parsed.data.trees.length === 0) {
        return [];
      }

      return parsed.data.trees.
      map((dependency) => {
        const [name, version] = dependency.name.split("@");

        if (isNotEmptyString(name) === false || isNotEmptyString(version) === false) {
          throw new Error(`Could not parse dependency name "${dependency.name}"`);
        }

        return {
          name,
          version };

      }).
      sort(sortByName);
    }) } };

/* eslint-disable jsdoc/no-undefined-types */

// node v4 has no dedicated constants object.
// Remove this if node v4 is not supported anymore.
const FS_CONSTANTS = fs.constants === undefined ? fs : fs.constants;

function checkCwd(cwd) {
  if (typeof cwd !== "string") {
    throw new RequiredOptionMissingError("cwd", cwd);
  }
}

function checkUse(use) {
  if (USE_OPTIONS.indexOf(use) === -1) {
    throw new OptionValueNotSupportedError("use", use);
  }
}

function checkUpdateTo(updateTo) {
  if (UPDATE_TO_OPTIONS.indexOf(updateTo) === -1) {
    throw new OptionValueNotSupportedError("updateTo", updateTo);
  }
}

function checkSave(save) {
  if (SAVE_OPTIONS.indexOf(save) === -1) {
    throw new OptionValueNotSupportedError("save", save);
  }
}

function checkForYarnWithCustomReg(packageManager, registry) {
  if (packageManager === "yarn" && registry !== undefined) {
    throw new YarnWithCustomRegistryError();
  }
}

class Updtr extends EventEmitter {
  // TODO: Add typings for UpdtrConfig
  // eslint-disable-next-line
  /**
   * The config passed-in here should look identically to the CLI config.
   * Dash-cased properties should be renamed to camelCased.
   * The goal is to replicate the API of the CLI as close as possible so users don't
   * have to guess the options.
   *
   * @param {UpdtrConfig} config
   */
  constructor(config) {
    super();

    const cwd = config.cwd;
    const registry = config.registry;

    const packageManager = config.use === undefined ?
    USE_OPTIONS[0] :
    config.use;

    const updateTo = config.updateTo === undefined ?
    UPDATE_TO_OPTIONS[0] :
    config.updateTo;

    const exclude = Array.isArray(config.exclude) === true ?
    config.exclude :
    [];

    const save = config.save === undefined ? SAVE_OPTIONS[0] : config.save;

    checkCwd(cwd);
    checkUse(packageManager);
    checkForYarnWithCustomReg(packageManager, registry);
    checkUpdateTo(updateTo);
    checkSave(save);

    this.config = {
      cwd,
      use: packageManager,
      exclude,
      test: config.test,
      registry,
      updateTo,
      save };

    this.cmds = cmds[packageManager];
    this.parse = parse$1[packageManager];

    if (typeof config.test === "string") {
      this.cmds = {
        ...this.cmds,
        test: () => config.test };

    }
  }

  async canAccessPackageJson() {
    let result = true;

    try {
      await fs.access(
      path.join(this.config.cwd, "package.json"),
      FS_CONSTANTS.R_OK | FS_CONSTANTS.W_OK // eslint-disable-line no-bitwise
      );
    } catch (err) {
      result = false;
    }

    return result;
  }

  exec(cmd) {
    return exec(this.config.cwd, cmd);
  }

  readFile(filenameInCwd) {
    return fs.readFile(path.join(this.config.cwd, filenameInCwd), "utf8");
  }

  writeFile(filenameInCwd, contents) {
    return fs.writeFile(
    path.join(this.config.cwd, filenameInCwd),
    contents);

  }

  dispose() {
    this.removeAllListeners();
  }}

function create(config) {
  return new Updtr(config);
}

async function start() {
  const cwd = process.cwd();
  const config = { ...argv };

  const reporterConfig = {
    stream: process.stdout,
    testStdout: argv.testStdout };


  const reporter = reporters[argv.reporter];

  config.cwd = cwd;

  const updtr = create(config);

  reporter(updtr, reporterConfig);
  try {
    await run(updtr);
  } catch (err) {
    updtr.emit("error", err);
  }
}

start();
