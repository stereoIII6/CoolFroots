// SPDX-License-Identifier: MIT
pragma solidity >=0.7.0 <0.9.0;

import "@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol";
import {COOLFROOT} from "./FrootyCoolTingz.sol";

error NotOwner(address user);
error NoChange(uint256 id);
error NotYet(uint256 time);

contract FrootsUpdate is AutomationCompatible {
    uint256 l;

    mapping(uint256 => address) public count;
    mapping(address => uint256) private statecount;
    mapping(address => mapping(uint256 => State)) private statelist;
    COOLFROOT public froots;
    uint256 u;

    uint256 public immutable interval;
    uint256 public lastTimeStamp;

    struct State {
        address owner;
        uint256 tokenId;
        uint256 diasID;
        string status;
        uint256 time;
        uint256 budget;
        uint256 interval;
    }

    constructor(address _froots) {
        l=0;
        froots = COOLFROOT(_froots);
        interval = 60;
        lastTimeStamp = block.timestamp;
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (
            bool upkeepNeeded,
            bytes memory /* performData */
        )
    {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(
        bytes calldata /* performData */
    ) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - lastTimeStamp) > interval) {
            lastTimeStamp = block.timestamp;
            // action here
            // _doUpkeep();
            l++;
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }

    function setUpKeep(uint256 _budget, uint256 _interval)
        external
        returns (State memory)
    {
        uint256 tokenID = froots.minter(msg.sender);
        if (tokenID <= 0) revert NotOwner(msg.sender);
        uint256 diasID = froots.tid(tokenID);
        string memory statusNow = froots.status(tokenID);
        State memory state = State(
            msg.sender,
            tokenID,
            diasID,
            statusNow,
            block.timestamp,
            _budget,
            _interval
        );
        count[u] = msg.sender;
        statecount[msg.sender] = 0;
        statelist[msg.sender][statecount[msg.sender]] = state;
        statecount[msg.sender]++;
        u++;
        return state;
    }

    function _doUpkeep() internal {
        for (uint256 i; i <= u; i++) {
            // each user
            uint256 c = statecount[count[u]];
            uint256 tokenID = froots.minter(msg.sender);
            uint256 diasID = froots.tid(tokenID);
            string memory statusNow = froots.status(tokenID);
            uint256 unterval = interval * statelist[count[u]][c - 1].interval;
            uint256 laststamp = statelist[count[u]][c - 1].time;
            if (
                keccak256(abi.encodePacked(statusNow)) !=
                keccak256(abi.encodePacked(statelist[count[u]][c - 1].status))
            ) {
                if (laststamp + unterval <= block.timestamp) {
                    State memory state = State(
                        count[u],
                        tokenID,
                        diasID,
                        statusNow,
                        block.timestamp,
                        statelist[count[u]][c - 1].budget--,
                        statelist[count[u]][c - 1].interval
                    );
                    statelist[count[u]][c] = state;
                    statecount[count[u]]++;
                } else revert NotYet(laststamp + unterval);
            } else revert NoChange(diasID);
        }
    }

    function getStateCount(address _adr, uint256 _state)
        external
        view
        returns (State memory)
    {
        return statelist[_adr][_state];
    }
}


contract Counter is AutomationCompatibleInterface {
    /**
     * Public counter variable
     */
    uint public counter;

    /**
     * Use an interval in seconds and a timestamp to slow execution of Upkeep
     */
    uint public immutable interval;
    uint public lastTimeStamp;

    constructor(uint updateInterval) {
        interval = updateInterval;
        lastTimeStamp = block.timestamp;
        counter = 0;
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory /* performData */)
    {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - lastTimeStamp) > interval) {
            lastTimeStamp = block.timestamp;
            counter = counter + 1;
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }
}

