// SPDX-License-Identifier: MIT
pragma solidity >=0.7.0 <0.9.0;

import "@chainlink/contracts/src/v0.8/AutomationCompatible.sol";
import {COOLFROOT, Greenlist} from "./CoolFroots.sol";

error NotOwner(address user);
error NoChange(uint256 id);
error NotYet(uint256 time);

contract FrootsUpdate is AutomationCompatible {
    uint256 l;

    mapping(uint256 => address) public count;
    mapping(address => uint256) private statecount;
    mapping(address => mapping(uint256 => State)) private statelist;
    COOLFROOT public froots;
    uint256 u;

    uint256 public immutable interval;
    uint256 public lastTimeStamp;

    struct State {
        address owner;
        uint256 tokenId;
        uint256 diasID;
        string status;
        uint256 likes;
        uint256 time;
        uint256 budget;
        uint256 interval;
    }

    constructor(address _froots) {
        l=0;
        froots = COOLFROOT(_froots);
        interval = 60;
        lastTimeStamp = block.timestamp;
    }

    function checkUpkeep(
        bytes calldata checkData
    )
        external
        view
        override
        returns (
            bool upkeepNeeded  ,
             bytes memory  performData 
        )
    {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
        performData = checkData;
    }

    function performUpkeep(
        bytes calldata /* performData */
    ) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - lastTimeStamp) > interval) {
            lastTimeStamp = block.timestamp;
            // action here
            _doUpkeep();
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }

    function setUpKeep(uint256 _budget, uint256 _interval)
        external
        returns (State memory)
    {
        uint256 tokenID = froots.minter(msg.sender);
        if (tokenID <= 0) revert NotOwner(msg.sender);
        uint256 diasID = froots.tid(tokenID);
        string memory statusNow = froots.status(tokenID);
        State memory state = State(
            msg.sender,
            tokenID,
            diasID,
            statusNow,
            0,
            block.timestamp,
            _budget,
            _interval
        );
        count[u] = msg.sender;
        statecount[msg.sender] = 0;
        statelist[msg.sender][statecount[msg.sender]] = state;
        statecount[msg.sender]++;
        u++;
        
        return state;
    }
    function _doUpkeep() internal {
        for (uint256 i=0; i <= u; i++) {
            // each user
            address user = count[u];
            uint256 c = statecount[user];
            uint256 tokenID = froots.minter(user);
            uint256 diasID = froots.tid(tokenID);
            string memory statusNow = froots.status(tokenID);
            uint256 unterval = interval * statelist[user][c - 1].interval;
            uint256 laststamp = statelist[user][c - 1].time;
            if (
                keccak256(abi.encodePacked(statusNow)) !=
                keccak256(abi.encodePacked(statelist[count[u]][c - 1].status))
            ) {
            if (laststamp + unterval <= block.timestamp) {
                    
                    State memory state = State(
                        count[u],
                        tokenID,
                        diasID,
                        statusNow,
                        0,
                        block.timestamp,
                        statelist[count[u]][c - 1].budget--,
                        statelist[count[u]][c - 1].interval
                    );
                    statelist[count[u]][c] = state;
                    statecount[count[u]]++;
                
                } else revert NotYet(laststamp + unterval);
            } else revert NoChange(diasID); 
                
        }
        l++; 
    }
    function doUpdate() external {
        _doUpkeep();
    }
    function getStateCount(address _adr, uint256 _state)
        external
        view
        returns (State memory)
    {
        return statelist[_adr][_state];
    }
}


contract GreenUpdate is AutomationCompatibleInterface {

    uint public counter;
    string message;
    Greenlist public gl;
    uint public immutable interval;
    uint public lastTimeStamp;

    constructor(address _gl) {
        interval = 60 * 5;
        lastTimeStamp = block.timestamp;
        counter = 0;
        gl = Greenlist(_gl);
        // 
    }

    function checkUpkeep(
        bytes calldata checkData
    )
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory performData)
    {
        string memory nu = gl.message();
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval && keccak256(abi.encodePacked(message)) != keccak256(abi.encodePacked(nu));
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
        performData = checkData;
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        string memory nu = gl.message();
        if ((block.timestamp - lastTimeStamp) > interval && keccak256(abi.encodePacked(message)) != keccak256(abi.encodePacked(nu)) ) {
            lastTimeStamp = block.timestamp;
            counter = counter + 1;
            gl.saveState();
            message = gl.message();
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }
}



